<!DOCTYPE html>
<html lang="fr-fr">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Appsec & DevSecOps - ben's lab
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" type="text/css" href="/css/poole.css">
  <link rel="stylesheet" type="text/css" href="/css/syntax.css">
  <link rel="stylesheet" type="text/css" href="/css/hyde.css">
  <link rel="stylesheet" type="text/css" href="/css/style.css">
  <link rel="stylesheet" type="text/css" href="/css/asciinema-player.css">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600">
  <link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
  <!-- Icons -->

  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
  <link rel="manifest" href="/assets/res/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="ben's lab" />

  <script src="/assets/res/jquery-3.1.0.min.js"></script>

  <!-- Google analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127625633-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-127625633-1');
</script>

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Appsec &amp; DevSecOps" />
<meta name="author" content="Ben" />
<meta property="og:locale" content="en_EN" />
<meta name="description" content="Appsec &amp; DevSecOps" />
<meta property="og:description" content="Appsec &amp; DevSecOps" />
<link rel="canonical" href="/" />
<meta property="og:url" content="/" />
<meta property="og:site_name" content="ben’s lab" />
<script type="application/ld+json">
{"headline":"Appsec &amp; DevSecOps","@type":"WebSite","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/icones/logo.png"},"name":"Ben"},"url":"/","name":"ben’s lab","author":{"@type":"Person","name":"Ben"},"description":"Appsec &amp; DevSecOps","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Twitter card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="ben's lab" />
  <meta name="twitter:creator" content="Ben" />
  <meta name="twitter:title" content="Appsec & DevSecOps" />
  <meta name="twitter:description" content="Appsec & DevSecOps" />
  
  <meta name="twitter:image" content="/assets/icones/logo.png" />
  

  <!-- asccinema -->
  <script>
    function launchOrPausePlayer(id) {
      var player = document.getElementById(id)
      var playing = player.attributes.getNamedItem("playing").value

      if(playing == "false") {
        player.play()
        player.setAttribute("playing", "true")
      }
      else {
        player.pause()
        player.setAttribute("playing", "false")
      }
    }
  </script>
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a href="/">
          ben's lab
        </a>
      </h1>
      <p class="lead">Appsec & DevSecOps</p>
    </div>

    <div class="sidebar-section">
        <nav class="sidebar-nav">
          <a class="sidebar-nav-item active" href="/">Articles</a>
    
          
          
            
              
                <a class="sidebar-nav-item" href="/about/">About</a>
              
            
          
            
              
                <a class="sidebar-nav-item" href="/archives.html">Archives</a>
              
            
          
            
          
            
              
            
          
            
          
            
          
            
          
        </nav>
    </div>

    <div class="sidebar-section">
        <p>Favorites</p>
        <a href="https://www.zenk-security.com" target="_blank">Zenk-Security</a><br />
    </div>

    <p class="sidebar-copyright">&copy; 2018. All rights reserved.</p>
    <div class="sidebar-social">
    <ul>
      <li><a href="https://github.com/ben-appsec" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
      <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
    </ul>
    </div>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
  
    <p class="post-cover">
      <img src="/assets/uploads/2018/golang-reverse-proxy-2-4/docker_heavy.png" alt="Securing a shared Docker socket using a Golang reverse-proxy (2/4)" title="Securing a shared Docker socket using a Golang reverse-proxy (2/4)" />
    </p>
  
    <h1 class="post-title">
      <a href="/golang-reverse-proxy-2-4/">
        Securing a shared Docker socket using a Golang reverse-proxy (2/4)
      </a>
    </h1>

    <div class="post-info">
      <p class="alignleft"><span class="google-icon-date">10 Oct 2018</span> <a class="post-comments-count" href="/golang-reverse-proxy-2-4/#disqus_thread" data-disqus-identifier=""></a></p>
      <p class="alignright">Author : <strong>Ben</strong></p>
    </div>

    <h2 id="introduction">Introduction</h2>

<p>In the <a href="/golang-reverse-proxy-2-4/]">previous part</a> of this article series, we discussed :</p>
<ul>
  <li>How sharing the Docker socket with a container can lead to container escape and privilege escalation on the host.</li>
  <li>Why current Docker client’s permissions mechanisms are somewhat unadapted (or at least to my needs).</li>
  <li>How building a Golang reverse-proxy, handling clients authentication and permissions management to protect the Docker socket, can solve those issues.</li>
</ul>

<p>In this article, we are going to discuss how to build a basic reverse proxy in Go and how to put it in a Docker image built <code class="highlighter-rouge">FROM SCRATCH</code>.</p>

<h2 id="building-a-basic-go-reverse-proxy">Building a basic Go Reverse-Proxy</h2>

<p>So let’s start by what any developer would do, <del>read the documentation,</del> google if someone already did it. And lucky us, <a href="https://twitter.com/mlowicki">Michał Łowicki</a> from Opera wrote a great <a href="https://medium.com/@mlowicki/http-s-proxy-in-golang-in-less-than-100-lines-of-code-6a51c2f2c38c">blog post</a> on the topic.</p>

<p>In his implementation :</p>
<ul>
  <li>A web server wait for clients’ requests.</li>
  <li>An handler function receives HTTP requests, forward them to targeted web server and send the server’s responses back to the client.</li>
  <li>An handler function receives HTTPS requests, establishing a tunnel between the client and the server using <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT">HTTP CONNECT</a>.</li>
</ul>

<p>Such design is perfect for us, since we can add our filtering logic in the handler function and block requests if needed (see part 3 of this article series).
Futhermore, the use of a basic http server allows to act as a transparent reverse-proxy, which guarantee compatibility with any Docker client implementation (ie. docker official client, jenkins plugins and such).</p>

<p>However, we have to remove the <code class="highlighter-rouge">HTTP CONNECT</code> implementation used to support HTTPS. Indeed, we will forward clients’ requests to a unix socket, thus we need to secure the connection between the clients and our proxy, not from the proxy to a web server. Additionally, we need to be able to analyse client requests’ content, which is not possible with an <code class="highlighter-rouge">HTTP CONNECT</code> tunnel. Thus let’s start small and implement a basic HTTP reverse-proxy, HTTPS and client authentication will be added later (see part 4 of this article series).</p>

<p>First we setup the HTTP server :</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">

    </span><span class="n">server</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">http</span><span class="o">.</span><span class="n">Server</span><span class="p">{</span><span class="x">
        </span><span class="n">Addr</span><span class="o">:</span><span class="x"> </span><span class="s">":8888"</span><span class="p">,</span><span class="x">
        </span><span class="n">Handler</span><span class="o">:</span><span class="x"> </span><span class="n">http</span><span class="o">.</span><span class="n">HandlerFunc</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">w</span><span class="x"> </span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="n">handleHTTP</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="p">)}),</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">())</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>Then we add the HTTP handler with a couple modifications. The handler receive two “objects”, a ResponseWriter to answer to the client and the client’s request :</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">handleHTTP</span><span class="p">(</span><span class="n">w</span><span class="x"> </span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="x"> </span><span class="n">req</span><span class="x"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">

    </span><span class="n">u</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">httpunix</span><span class="o">.</span><span class="n">Transport</span><span class="p">{</span><span class="x"> </span><span class="c">//[1]</span><span class="x">
        </span><span class="n">DialTimeout</span><span class="o">:</span><span class="x">           </span><span class="m">100</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">,</span><span class="x">
        </span><span class="n">RequestTimeout</span><span class="o">:</span><span class="x">        </span><span class="m">1</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span><span class="x">
        </span><span class="n">ResponseHeaderTimeout</span><span class="o">:</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="n">u</span><span class="o">.</span><span class="n">RegisterLocation</span><span class="p">(</span><span class="s">"docker-socket"</span><span class="p">,</span><span class="x"> </span><span class="s">"/var/run/docker.sock"</span><span class="p">)</span><span class="x"> </span><span class="c">//[2]</span><span class="x">

    </span><span class="n">req</span><span class="o">.</span><span class="n">URL</span><span class="o">.</span><span class="n">Scheme</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"http+unix"</span><span class="x">    </span><span class="c">//[3]</span><span class="x">
    </span><span class="n">req</span><span class="o">.</span><span class="n">URL</span><span class="o">.</span><span class="n">Host</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"docker-socket"</span><span class="x">  </span><span class="c">//[4]</span><span class="x">

    </span><span class="n">resp</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">u</span><span class="o">.</span><span class="n">RoundTrip</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="x">   </span><span class="c">//[5]</span><span class="x">
    
    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">http</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">(),</span><span class="x"> </span><span class="n">http</span><span class="o">.</span><span class="n">StatusServiceUnavailable</span><span class="p">)</span><span class="x"> </span><span class="c">//[6]</span><span class="x">
        </span><span class="k">return</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">//[7]</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">
    </span><span class="n">copyHeader</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">Header</span><span class="p">(),</span><span class="x"> </span><span class="n">resp</span><span class="o">.</span><span class="n">Header</span><span class="p">)</span><span class="x">
    </span><span class="n">w</span><span class="o">.</span><span class="n">WriteHeader</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">StatusCode</span><span class="p">)</span><span class="x">
    </span><span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="x"> </span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<ol>
  <li>Create a new <a href="https://godoc.org/github.com/tv42/httpunix">httpunix</a> <code class="highlighter-rouge">Transport</code> instance which will be used to request the socket.</li>
  <li>Indicate that requests to the hostname <code class="highlighter-rouge">docker-socket</code> actually target the docker unix socket.</li>
  <li>The client request’s <code class="highlighter-rouge">Sheme</code> value is <code class="highlighter-rouge">http</code>. Since we redirect it to a unix socket, we have to change it to <code class="highlighter-rouge">http+unix</code>.</li>
  <li>Force the targeted hostname to <code class="highlighter-rouge">docker-socket</code> in the client’s request. This allow us to have any hostname value for our running container. Also, we don’t offer actual proxy capabilities and alway want to redirect to the docker socket.</li>
  <li>Forward the modified client request to the docker socket.</li>
  <li>If the request fail, we send a standard <code class="highlighter-rouge">Status Service Unavailable</code> error to the client.</li>
  <li>Else, we forward the answer of the docker API to the client.</li>
</ol>

<h2 id="building-a-docker-image-from-scratch">Building a Docker image from scratch</h2>

<p>A Docker image is built based on a <code class="highlighter-rouge">Dockerfile</code>, describing steps required to create it. In our case, a basic Docker image would look like this :</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> golang</span>

<span class="k">COPY</span><span class="s"> src/reverse-proxy.go /go/src/      #[1]</span>
<span class="k">RUN </span>go get github.com/tv42/httpunix     <span class="c">#[2]</span>
<span class="k">RUN </span>go build src/reverse-proxy.go       <span class="c">#[3]</span>

<span class="k">RUN </span><span class="nb">mv</span> /go/reverse-proxy /bin/reverse-proxy <span class="c">#[4]</span>
<span class="k">USER</span><span class="s"> root                                   #[5]</span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/reverse-proxy"] #[6]</span>
</code></pre></div></div>

<ol>
  <li>Move the source code to the container.</li>
  <li>Get required Go dependencies.</li>
  <li>Compile our source code.</li>
  <li>Move the output to <code class="highlighter-rouge">/bin</code>.</li>
  <li>Set the user as root (required to access the docker-socket).</li>
  <li>Define <code class="highlighter-rouge">/bin/reverse-proxy</code> as the entry point.</li>
</ol>

<p>Nothing too fancy or difficult here. However, <a href="/golang-reverse-proxy-1-4/#securing-the-docker-socket-using-nginx-">security concerns</a> aside, do we really want a container with a <a href="https://hub.docker.com/r/library/golang/tags/">295MB</a> base image ? Probably not. Thanks to the use of a <a href="https://docs.docker.com/develop/develop-images/multistage-build/">multi-stage builds</a> Dockerfile, we can build our reverse proxy <a href="/golang-reverse-proxy-1-4/#scratch-images-and-golang-to-the-rescue">statically</a> and add the resulting binary in an empty container.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> golang as build #[1]</span>
<span class="k">COPY</span><span class="s"> reverse-proxy.go /go/src/</span>
<span class="k">RUN </span>go get github.com/tv42/httpunix
<span class="k">RUN </span><span class="nv">CGO_ENABLED</span><span class="o">=</span>0 <span class="nv">GOOS</span><span class="o">=</span>linux go build <span class="nt">-a</span> <span class="nt">-ldflags</span> <span class="s1">'-extldflags "-static"'</span> src/reverse-proxy.go <span class="c">#[2]</span>

<span class="k">FROM</span><span class="s"> scratch</span>
<span class="k">COPY</span><span class="s"> --from=build /go/reverse-proxy /bin/reverse-proxy #[3]</span>
<span class="k">USER</span><span class="s"> root</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/reverse-proxy"]</span>
</code></pre></div></div>

<p>Our key additions :</p>
<ol>
  <li>Define the golang container as a build step named <code class="highlighter-rouge">build</code>.</li>
  <li>Compile the binary statically.</li>
  <li>Move the compiled binary from our <code class="highlighter-rouge">build</code> container to the scratch container.</li>
</ol>

<p>The result is a container with a size of 6.5MB and an as small as possible attack surface.</p>

<h2 id="putting-everything-together">Putting everything together</h2>

<p>A working proof-of-concept is available <a href="https://github.com/ben-appsec/blog-material/tree/master/golang-reverse-proxy-2">here</a> for testing purpose. A docker-compose file is provided, which builds and launches the container. Once running, the container makes available the host’s docker socket through the reverse proxy on <code class="highlighter-rouge">localhost</code> port <code class="highlighter-rouge">8888</code>.</p>

<p>How to run it :</p>
<ul>
  <li><code class="highlighter-rouge">git clone https://github.com/ben-appsec/blog-material.git</code></li>
  <li><code class="highlighter-rouge">cd blog-material/golang-reverse-proxy-2</code></li>
  <li><code class="highlighter-rouge">docker-compose up</code></li>
  <li><code class="highlighter-rouge">docker -H=127.0.0.1:8888 container ls</code></li>
</ul>

<p><em>Note: docker and docker-compose must be installed.</em></p>

<details>
    <summary style="" onclick="javascript:launchOrPausePlayer('poc-reverse-proxy')">Demo</summary>
    <asciinema-player id="poc-reverse-proxy" src="/assets/uploads/2018/golang-reverse-proxy-2-4/poc-reverse-proxy.cast" playing="false" speed="1.5" idle-time-limit="0.9" rows="20" cols="90"></asciinema-player>
    <script>
            var width = window.innerWidth
            var player = document.getElementById("poc-reverse-proxy")

            if(width < 1270 && width >= 768) {
                player.setAttribute("cols", Math.round(width/1270*80))
            }
            else if(width < 768){
                player.setAttribute("cols", Math.round(width/768*80))
            }
    </script>
</details>
<p></p>

<h2 id="whats-next-">What’s next ?</h2>

<p>Now that we have a working basic reverse-proxy, we will see in part 3 how to add permissions management capabilities, based on a configuration file generated from the <a href="https://docs.docker.com/engine/api/v1.37/">Docker OpenAPI specification</a>.</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="https://medium.com/@mlowicki/http-s-proxy-in-golang-in-less-than-100-lines-of-code-6a51c2f2c38c">https://medium.com/@mlowicki/http-s-proxy-in-golang-in-less-than-100-lines-of-code-6a51c2f2c38c</a></li>
  <li><a href="https://godoc.org/github.com/tv42/httpunix">https://godoc.org/github.com/tv42/httpunix</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT</a></li>
  <li><a href="https://docs.docker.com/develop/develop-images/multistage-build/">https://docs.docker.com/develop/develop-images/multistage-build/</a></li>
</ul>


     
     
    
    <hr />
  </div>
  
  <div class="post">
  
    <p class="post-cover">
      <img src="/assets/uploads/2018/golang-reverse-proxy-1-4/golang_and_docker.png" alt="Securing a shared Docker socket using a Golang reverse-proxy (1/4)" title="Securing a shared Docker socket using a Golang reverse-proxy (1/4)" />
    </p>
  
    <h1 class="post-title">
      <a href="/golang-reverse-proxy-1-4/">
        Securing a shared Docker socket using a Golang reverse-proxy (1/4)
      </a>
    </h1>

    <div class="post-info">
      <p class="alignleft"><span class="google-icon-date">24 Sep 2018</span> <a class="post-comments-count" href="/golang-reverse-proxy-1-4/#disqus_thread" data-disqus-identifier=""></a></p>
      <p class="alignright">Author : <strong>Ben</strong></p>
    </div>

    <h2 id="introduction">Introduction</h2>

<p>If you already worked a bit with Docker, maybe did you end-up in a situation were you needed to launch/create/manage a new container <strong>from</strong> an already existing one. For example, when you are running a dockerized Jenkins instance and need to create ephemeral containers in your pipeline to perform build tasks.</p>

<p>In such case, a quick Google search will offers you two main options :</p>
<ul>
  <li>
    <p><strong>Docker inside Docker (DinD) :</strong> you perform a full Docker installation within you container. Basically, you run Docker on top of another Docker. I’m not a big fan of this approach and some people much more knowledgeable than me have explained <a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">why it might be a bad idea</a> (spoiler: filesystem issues and risks of corruption). This options however seems to remain relevant in some cases, for instance if you are using <a href="https://applatix.com/case-docker-docker-kubernetes-part/">Kubernetes</a>.</p>
  </li>
  <li>
    <p><strong>Docker outside Docker (DooD) :</strong> you share the Docker daemon socket of the host with your hosted container using the <code class="highlighter-rouge">--volume</code> or <code class="highlighter-rouge">-v</code> flags :</p>

    <p><code class="highlighter-rouge">docker run -ti --rm -v /var/run/docker.sock:/var/run/docker.sock alpine</code></p>

    <p>Once inside the container, performing a request to the Docker API become as simple as installing <code class="highlighter-rouge">curl</code> and doing :</p>

    <p><code class="highlighter-rouge">curl --unix-socket /var/run/docker.sock http://localhost/containers/json</code></p>
  </li>
</ul>

<details>
    <summary style="margin-left: 25px" onclick="javascript:launchOrPausePlayer('player-demo-wget')">Demo</summary>
    <asciinema-player id="player-demo-wget" src="/assets/uploads/2018/golang-reverse-proxy-1-4/curl_docker_socket.cast" playing="false" speed="2.5" idle-time-limit="0.9" rows="20" cols="90"></asciinema-player>
    <script>
            var width = window.innerWidth
            var player = document.getElementById("player-demo-wget")

            if(width < 1270 && width >= 768) {
                player.setAttribute("cols", Math.round(width/1270*80))
            }
            else if(width < 768){
                player.setAttribute("cols", Math.round(width/768*80))
            }
    </script>
</details>
<p></p>

<p>In my case, I’m running my containers on a small dedicated server using Docker compose. Mainly to perform per commit build jobs on a couple of open-source projects I follow. So DinD doesn’t seems like a good option.</p>

<h2 id="container-escape-using-the-docker-daemon-socket">Container escape using the Docker daemon socket</h2>

<p>This left us with the DooD approach. However, as a former “offensive security” guy, I can’t accept to break the isolation between my containers and my host so easily. Indeed, as stated by the Docker documentation : <em>“Docker’s out-of-the-box authorization model is all or nothing. Any user with permission to access the Docker daemon can run any Docker client command. The same is true for callers using Docker’s Engine API to contact the daemon.”</em></p>

<p>Which mean that in case of compromising of a container with access to the Docker socket, getting root access on the host can be easily achieved. All  an attacker would have to do is to download the standalone <a href="https://download.docker.com/linux/static/stable/x86_64/">docker client</a>, launch a new busybox container mounting the root of the host to a directory, and then chroot into it :</p>

<p><code class="highlighter-rouge">docker run -u 0 -ti --rm -v /:/media/host/ busybox chroot /media/host</code></p>

<details>
    <summary style="" onclick="javascript:launchOrPausePlayer('docker-privesc1')">Demo</summary>
    <asciinema-player id="docker-privesc1" src="/assets/uploads/2018/golang-reverse-proxy-1-4/docker_privesc1.cast" playing="false" speed="2" idle-time-limit="0.9" rows="20" cols="90"></asciinema-player>
    <script>
            var width = window.innerWidth
            var player = document.getElementById("docker-privesc1")

            if(width < 1270 && width >= 768) {
                player.setAttribute("cols", Math.round(width/1270*80))
            }
            else if(width < 768){
                player.setAttribute("cols", Math.round(width/768*80))
            }
    </script>
</details>
<p></p>

<p><em>Note : This is the exact same reason why being in the docker group is considered equal having root privilege. It works from the host too :</em></p>

<details>
    <summary style="" onclick="javascript:launchOrPausePlayer('docker-privesc2')">Demo</summary>
    <asciinema-player id="docker-privesc2" src="/assets/uploads/2018/golang-reverse-proxy-1-4/docker_privesc2.cast" playing="false" speed="1.25" idle-time-limit="0.9" rows="20" cols="90"></asciinema-player>
    <script>
            var width = window.innerWidth
            var player = document.getElementById("docker-privesc2")

            if(width < 1270 && width >= 768) {
                player.setAttribute("cols", Math.round(width/1270*80))
            }
            else if(width < 768){
                player.setAttribute("cols", Math.round(width/768*80))
            }
    </script>
</details>
<p></p>

<h2 id="dockers-built-in-hardening-options">Docker’s built-in hardening options</h2>

<p>Docker allow to protect the daemon socket using :</p>
<ol>
  <li>Mutual <a href="https://docs.docker.com/engine/security/https/">client-server authentication</a> through TLS and x509.</li>
  <li>The Docker Engine <a href="https://docs.docker.com/engine/extend/">managed plugin system</a>, allowing to <a href="https://docs.docker.com/engine/extend/plugins_authorization/">create an authorization plugin</a>.</li>
</ol>

<p>Regarding the first point, it’s a great feature. However, if a container with access to the Docker socket is compromised, the attacker will also most likely have access to the client certificate. In such case, the scenario presented previously is still relevant.</p>

<p>Regarding the second point, no official authorization plugin is provided. <a href="https://www.google.com/search?q=docker+authorization+plugin">Multiple implementation exist</a>, more or less functional and more or less maintained. I’m not a big fan of Docker plugins, since they are a bit anti-idiomatic with the “Build Once, Deploy Anywhere” philosophy.</p>

<h2 id="securing-the-docker-socket-using-nginx-">Securing the Docker socket using Nginx ?</h2>

<p>When I saw that the Docker socket give access to a Web API, my first though was “reverse-proxy”. If you are not familiar with this concept, a reverse-proxy stand between a web server and its clients and forward their requests to it. A reverse-proxy also allows to perform different tasks such as caching, load-balancing and… requests filtering ! To solve our issue, we can mount our Docker socket into a revers-proxy container, configure our Docker client to work with a remote socket and filter its HTTP requests to the API to only allow what we want.</p>

<p><img src="/assets/uploads/2018/golang-reverse-proxy-1-4/schema-reverse-proxy.jpg" alt="Static Library Link" /></p>

<p>One of the most commonly used reverse proxy is Nginx, which happens to have a ready to use official image on <a href="https://hub.docker.com/_/nginx/">Dockerhub</a>. Neat right ? No.</p>

<p>By doing so, we basically move our risk of compromising from the Jenkins container to the Nginx one. The attack surface is reduced (since Jenkins is <a href="https://www.cvedetails.com/product/34004/Jenkins-Jenkins.html?vendor_id=15865">not really</a> the most secure software ever), but we still end-up with a full-sized Docker container, either based on <a href="https://justi.cz/security/2018/09/13/alpine-apk-rce.html">alpine</a> or <a href="http://dance.csc.ncsu.edu/papers/codaspy17.pdf">debian</a>, running a service with much more features than actually needed.</p>

<p>In some (most ?) cases it may seems like an acceptable solution, but let’s get paranoid and see how we can do it better.</p>

<h2 id="scratch-images-and-golang-to-the-rescue">Scratch images and Golang to the rescue</h2>

<p>A neat way to have an as empty as possible Docker image is to build it “FROM scratch”, which basically means that your image will <a href="https://embano1.github.io/post/scratch/">“only”</a> contains what you put in it. No <code class="highlighter-rouge">sh</code>, no <code class="highlighter-rouge">/bin</code>, no <code class="highlighter-rouge">/lib</code>, no <code class="highlighter-rouge">thing</code>. The first question that should come up to your mind is : <em>What about dependencies ?</em></p>

<p>If you are coding in Java you need the JVM, if you are coding in Python you need the Python interpreter, and if you are coding in C/C++ you need your original <em>Jurassic Park</em> t-shirt and <em>Stranger Things</em> in the background for maximum efficiency. We don’t want that.</p>

<p>Luckily, Golang is a language offering just the level of abstraction we need to code a reverse-proxy painlessly while offering all the capabilities of a compiled language, including <strong>static compilation</strong>.</p>

<p><img src="/assets/uploads/2018/golang-reverse-proxy-1-4/StaticLibraryLink.png" alt="Static Library Link" /></p>

<p>Static compilation is a compilation process resulting in a standalone binary embedding all its dependencies. For instance, a software developed in C and statically compiled won’t rely on the system <code class="highlighter-rouge">libc</code> but the one it as been compiled with. The same thing can easily be achieved in Go :</p>

<p><code class="highlighter-rouge">CGO_ENABLED=0 GOOS=linux go build -a -ldflags '-extldflags "-static"' src/reverse-proxy.go</code></p>

<h2 id="we-got-a-plan-">We got a plan !</h2>

<p>With this information in mind, all we now have to do is apply the classic “make it work, then make it better” method :</p>
<ol>
  <li>Create a basic Go reverse-proxy and move it to a scratch image</li>
  <li>Add filtering capabilities</li>
  <li>Add HTTPS support, client authentication and per client filtering policies</li>
</ol>

<p>Each of those points will be the subject of dedicated blog posts in this series.</p>

<h2 id="alternative-solutions">Alternative solutions</h2>

<p>If you are looking for a production ready solution and are not really interested by the DIY part, you may want to have a look at :</p>
<ul>
  <li><a href="https://github.com/open-policy-agent/opa">Open Policy Agent</a>, a general-purpose policy engine which happens to have a tutorial for <a href="https://www.openpolicyagent.org/docs/docker-authorization.html">this exact use case</a>. However it requires to install a Docker plugin and doesn’t offer actual client authentication.</li>
  <li><a href="https://github.com/TykTechnologies/tyk">Tyk</a>, a lightweight API Gateway coded in Go, offering filtering capabilities. However, it doesn’t seem to filter parameters.</li>
  <li>Your current API gateway or reverse-proxy that may offer some kind of ACL capabilities for API requests.</li>
</ul>

<h2 id="references">References</h2>
<ul>
  <li><a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/</a></li>
  <li><a href="https://applatix.com/case-docker-docker-kubernetes-part/">https://applatix.com/case-docker-docker-kubernetes-part/</a></li>
  <li><a href="https://justi.cz/security/2018/09/13/alpine-apk-rce.html">https://justi.cz/security/2018/09/13/alpine-apk-rce.html</a></li>
  <li><a href="http://dance.csc.ncsu.edu/papers/codaspy17.pdf">http://dance.csc.ncsu.edu/papers/codaspy17.pdf</a></li>
  <li><a href="https://embano1.github.io/post/scratch/">https://embano1.github.io/post/scratch/</a></li>
  <li><a href="https://www.bogotobogo.com/cplusplus/libraries.php">https://www.bogotobogo.com/cplusplus/libraries.php</a></li>
  <li><a href="https://github.com/TykTechnologies/tyk">https://github.com/TykTechnologies/tyk</a></li>
  <li><a href="https://www.openpolicyagent.org/docs/docker-authorization.html">https://www.openpolicyagent.org/docs/docker-authorization.html</a></li>
</ul>


     
     
    
    <hr />
  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Previous</span>
  
  
    <span class="pagination-item newer">Next</span>
  
</div>

    </div>

  <script src="/assets/res/asciinema-player.js"></script>
  <script src="/assets/res/anchor.min.js"></script>
  <script src="/assets/res/script.js"></script>
  </body>
</html>
