<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ben's lab</title>
    <description>Appsec and DevSecOps</description>
    <link>//</link>
    <atom:link href="//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 29 Sep 2018 13:22:23 -0500</pubDate>
    <lastBuildDate>Sat, 29 Sep 2018 13:22:23 -0500</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Protecting a shared Docker socket using a Golang reverse-proxy (1/4)</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;If you already worked a bit with Docker, maybe did you end-up in a situation were you needed to launch/create/manage a new container &lt;strong&gt;from&lt;/strong&gt; an already existing one. For example, when you are running a dockerized Jenkins instance and need to create ephemeral containers in your pipeline to perform build tasks.&lt;/p&gt;

&lt;p&gt;In such case, a quick Google search will offers you two main options :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Docker inside Docker (DinD) :&lt;/strong&gt; you perform a full Docker installation within you container. Basically, you run Docker on top of another Docker. I’m not a big fan of this approach and some people much more knowledgeable than me have explained &lt;a href=&quot;https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&quot;&gt;why it might be a bad idea&lt;/a&gt; (spoiler: filesystem issues and risks of corruption). This options however seems to remain relevant in some cases, for instance if you are using &lt;a href=&quot;https://applatix.com/case-docker-docker-kubernetes-part/&quot;&gt;Kubernetes&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Docker outside Docker (DooD) :&lt;/strong&gt; you share the Docker daemon socket of the host with your hosted container using the &lt;code class=&quot;highlighter-rouge&quot;&gt;--volume&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; flags :&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -ti --rm -v /var/run/docker.sock:/var/run/docker.sock alpine&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Once inside the container, performing a request to the Docker API become as simple as installing &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; and doing :&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;curl --unix-socket /var/run/docker.sock http://localhost/containers/json&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;
    &lt;summary style=&quot;margin-left: 25px&quot; onclick=&quot;javascript:launchOrPausePlayer('player-demo-wget')&quot;&gt;Demo&lt;/summary&gt;
    &lt;asciinema-player id=&quot;player-demo-wget&quot; src=&quot;/assets/uploads/2018/golang-reverse-proxy-1-4/curl_docker_socket.cast&quot; playing=&quot;false&quot; speed=&quot;2.5&quot; idle-time-limit=&quot;0.9&quot; rows=&quot;20&quot; cols=&quot;90&quot;&gt;&lt;/asciinema-player&gt;
    &lt;script&gt;
            var width = window.innerWidth
            var player = document.getElementById(&quot;player-demo-wget&quot;)

            if(width &lt; 1270 &amp;&amp; width &gt;= 768) {
                player.setAttribute(&quot;cols&quot;, Math.round(width/1270*80))
            }
            else if(width &lt; 768){
                player.setAttribute(&quot;cols&quot;, Math.round(width/768*80))
            }
    &lt;/script&gt;
&lt;/details&gt;
&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Obviously, you can also install the Docker cli for a user experience identical to the one you have on the host.&lt;/p&gt;

&lt;p&gt;In my case, I’m running my containers on a small dedicated server using Docker compose. Mainly to perform per commit build jobs on a couple of open-source projects I follow. So DinD doesn’t seems like a good option.&lt;/p&gt;

&lt;h2 id=&quot;privilege-escalation-using-the-docker-daemon-socket&quot;&gt;Privilege escalation using the Docker daemon socket&lt;/h2&gt;

&lt;p&gt;This left us with the DooD approach. However, as a former “offensive security” guy, I can’t accept to break the isolation between my containers and my host so easily. Indeed, as stated by the Docker documentation : &lt;em&gt;“Docker’s out-of-the-box authorization model is all or nothing. Any user with permission to access the Docker daemon can run any Docker client command. The same is true for callers using Docker’s Engine API to contact the daemon.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Which mean that in case of compromising of a container with access to the Docker socket, getting root access on the host can be easily achieved. All  an attacker would have to do is to download the standalone &lt;a href=&quot;https://download.docker.com/linux/static/stable/x86_64/&quot;&gt;docker client&lt;/a&gt;, launch a new busybox container mounting the root of the host to a directory, and then chroot into it :&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -u 0 -ti --rm -v /:/media/host/ busybox chroot /media/host&lt;/code&gt;&lt;/p&gt;

&lt;details&gt;
    &lt;summary style=&quot;&quot; onclick=&quot;javascript:launchOrPausePlayer('docker-privesc1')&quot;&gt;Demo&lt;/summary&gt;
    &lt;asciinema-player id=&quot;docker-privesc1&quot; src=&quot;/assets/uploads/2018/golang-reverse-proxy-1-4/docker_privesc1.cast&quot; playing=&quot;false&quot; speed=&quot;2&quot; idle-time-limit=&quot;0.9&quot; rows=&quot;20&quot; cols=&quot;90&quot;&gt;&lt;/asciinema-player&gt;
    &lt;script&gt;
            var width = window.innerWidth
            var player = document.getElementById(&quot;docker-privesc1&quot;)

            if(width &lt; 1270 &amp;&amp; width &gt;= 768) {
                player.setAttribute(&quot;cols&quot;, Math.round(width/1270*80))
            }
            else if(width &lt; 768){
                player.setAttribute(&quot;cols&quot;, Math.round(width/768*80))
            }
    &lt;/script&gt;
&lt;/details&gt;
&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note : This is the exact same reason why being in the docker group is considered equal having root privilege. It works from the host too :&lt;/em&gt;&lt;/p&gt;

&lt;details&gt;
    &lt;summary style=&quot;&quot; onclick=&quot;javascript:launchOrPausePlayer('docker-privesc2')&quot;&gt;Demo&lt;/summary&gt;
    &lt;asciinema-player id=&quot;docker-privesc2&quot; src=&quot;/assets/uploads/2018/golang-reverse-proxy-1-4/docker_privesc2.cast&quot; playing=&quot;false&quot; speed=&quot;1.25&quot; idle-time-limit=&quot;0.9&quot; rows=&quot;20&quot; cols=&quot;90&quot;&gt;&lt;/asciinema-player&gt;
    &lt;script&gt;
            var width = window.innerWidth
            var player = document.getElementById(&quot;docker-privesc2&quot;)

            if(width &lt; 1270 &amp;&amp; width &gt;= 768) {
                player.setAttribute(&quot;cols&quot;, Math.round(width/1270*80))
            }
            else if(width &lt; 768){
                player.setAttribute(&quot;cols&quot;, Math.round(width/768*80))
            }
    &lt;/script&gt;
&lt;/details&gt;
&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&quot;dockers-built-in-hardening-options&quot;&gt;Docker’s built-in hardening options&lt;/h2&gt;

&lt;p&gt;Docker allow to protect the daemon socket using :&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Mutual &lt;a href=&quot;https://docs.docker.com/engine/security/https/&quot;&gt;client-server authentication&lt;/a&gt; through TLS and x509.&lt;/li&gt;
  &lt;li&gt;The Docker Engine &lt;a href=&quot;https://docs.docker.com/engine/extend/&quot;&gt;managed plugin system&lt;/a&gt;, allowing to &lt;a href=&quot;https://docs.docker.com/engine/extend/plugins_authorization/&quot;&gt;create an authorization plugin&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Regarding the first point, it’s a great feature. However, if a container with access to the Docker socket is compromised, the attacker will also most likely have access to the client certificate. In such case, the scenario presented previously is still relevant.&lt;/p&gt;

&lt;p&gt;Regarding the second point, no official authorization plugin is provided. &lt;a href=&quot;https://www.google.com/search?q=docker+authorization+plugin&quot;&gt;Multiple implementation exist&lt;/a&gt;, more or less functional and more or less maintained. I’m not a big fan of Docker plugins, since they are a bit anti-idiomatic with the “Build Once, Deploy Anywhere” philosophy.&lt;/p&gt;

&lt;h2 id=&quot;securing-the-docker-socket-using-nginx-&quot;&gt;Securing the Docker socket using Nginx ?&lt;/h2&gt;

&lt;p&gt;When I saw that the Docker socket give access to a Web API, my first though was “reverse-proxy”. If you are not familiar with this concept, a reverse-proxy stand between a web server and its clients and forward their requests to it. A reverse-proxy also allows to perform different tasks such as caching, load-balancing and… requests filtering ! To solve our issue, we can mount our Docker socket into a revers-proxy container, configure our Docker client to work with a remote socket and filter its HTTP requests to the API to only allow what we want.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/uploads/2018/golang-reverse-proxy-1-4/schema-reverse-proxy.jpg&quot; alt=&quot;Static Library Link&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One of the most commonly used reverse proxy is Nginx, which happens to have a ready to use official image on &lt;a href=&quot;https://hub.docker.com/_/nginx/&quot;&gt;Dockerhub&lt;/a&gt;. Neat right ? No.&lt;/p&gt;

&lt;p&gt;By doing so, we basically move our risk of compromising from the Jenkins container to the Nginx one. The attack surface is reduced (since Jenkins is &lt;a href=&quot;https://www.cvedetails.com/product/34004/Jenkins-Jenkins.html?vendor_id=15865&quot;&gt;not really&lt;/a&gt; the most secure software ever), but we still end-up with a full-sized Docker container, either based on &lt;a href=&quot;https://justi.cz/security/2018/09/13/alpine-apk-rce.html&quot;&gt;alpine&lt;/a&gt; or &lt;a href=&quot;http://dance.csc.ncsu.edu/papers/codaspy17.pdf&quot;&gt;debian&lt;/a&gt;, running a service with much more features than actually needed.&lt;/p&gt;

&lt;p&gt;In some (most ?) cases it may seems like an acceptable solution, but let’s get paranoid and see how we can do it better.&lt;/p&gt;

&lt;h2 id=&quot;scratch-images-and-golang-to-the-rescue&quot;&gt;Scratch images and Golang to the rescue&lt;/h2&gt;

&lt;p&gt;A neat way to have an as empty as possible Docker image is to build it “FROM scratch”, which basically means that your image will &lt;a href=&quot;https://embano1.github.io/post/scratch/&quot;&gt;“only”&lt;/a&gt; contains what you put in it. No &lt;code class=&quot;highlighter-rouge&quot;&gt;sh&lt;/code&gt;, no &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin&lt;/code&gt;, no &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib&lt;/code&gt;, no &lt;code class=&quot;highlighter-rouge&quot;&gt;thing&lt;/code&gt;. The first question that should come up to your mind is : &lt;em&gt;What about dependencies ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you are coding in Java you need the JVM, if you are coding in Python you need the Python interpreter and if you are coding in C/C++ you have to wear your original &lt;em&gt;Jurassic Park&lt;/em&gt; t-shirt, and code with &lt;em&gt;Stranger Things&lt;/em&gt; in the background for maximum efficiency. We don’t want that.&lt;/p&gt;

&lt;p&gt;Luckily, Golang is a language offering just the level of abstraction we need to code a reverse-proxy painlessly while offering all the capabilities of a compiled language, including &lt;strong&gt;static compilation&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/uploads/2018/golang-reverse-proxy-1-4/StaticLibraryLink.png&quot; alt=&quot;Static Library Link&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Static compilation is a compilation process resulting in a standalone binary embedding all its dependencies. For instance, a software developed in C and statically compiled won’t rely on the system &lt;code class=&quot;highlighter-rouge&quot;&gt;libc&lt;/code&gt; but the one it as been compiled with. The same thing can easily be achieved in Go :&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CGO_ENABLED=0 GOOS=linux go build -a -ldflags '-extldflags &quot;-static&quot;' src/reverse-proxy.go&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;we-got-a-plan-&quot;&gt;We got a plan !&lt;/h2&gt;

&lt;p&gt;With this information in mind, all we now have to do is apply the classic “make it work, then make it better” method :&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Create a basic Go reverse-proxy and move it to a scratch image&lt;/li&gt;
  &lt;li&gt;Add filtering capabilities&lt;/li&gt;
  &lt;li&gt;Add HTTPS support, client authentication and per client filtering policies&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each of those points will be the subject of dedicated blog posts in this series.&lt;/p&gt;

&lt;h2 id=&quot;alternative-solutions&quot;&gt;Alternative solutions&lt;/h2&gt;

&lt;p&gt;If you are looking for a production ready solution and are not really interested by the DIY part, you may want to have a look at :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/open-policy-agent/opa&quot;&gt;Open Policy Agent&lt;/a&gt;, a general-purpose policy engine which happens to have a tutorial for &lt;a href=&quot;https://www.openpolicyagent.org/docs/docker-authorization.html&quot;&gt;this exact use case&lt;/a&gt;. However it requires to install a Docker plugin and doesn’t offer actual client authentication.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/TykTechnologies/tyk&quot;&gt;Tyk&lt;/a&gt;, a lightweight API Gateway coded in Go, offering filtering capabilities. However, it doesn’t seem to filter parameters.&lt;/li&gt;
  &lt;li&gt;Your current API gateway or reverse-proxy that may offer some kind of ACL capabilities for API requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&quot;&gt;https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://applatix.com/case-docker-docker-kubernetes-part/&quot;&gt;https://applatix.com/case-docker-docker-kubernetes-part/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://justi.cz/security/2018/09/13/alpine-apk-rce.html&quot;&gt;https://justi.cz/security/2018/09/13/alpine-apk-rce.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://dance.csc.ncsu.edu/papers/codaspy17.pdf&quot;&gt;http://dance.csc.ncsu.edu/papers/codaspy17.pdf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://embano1.github.io/post/scratch/&quot;&gt;https://embano1.github.io/post/scratch/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bogotobogo.com/cplusplus/libraries.php&quot;&gt;https://www.bogotobogo.com/cplusplus/libraries.php&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/TykTechnologies/tyk&quot;&gt;https://github.com/TykTechnologies/tyk&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.openpolicyagent.org/docs/docker-authorization.html&quot;&gt;https://www.openpolicyagent.org/docs/docker-authorization.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 11:10:00 -0500</pubDate>
        <link>//golang-reverse-proxy-1-4/</link>
        <guid isPermaLink="true">//golang-reverse-proxy-1-4/</guid>
        
        <category>Docker</category>
        
        <category>Golang</category>
        
        
      </item>
    
  </channel>
</rss>
