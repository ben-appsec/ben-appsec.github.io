<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ben's lab</title>
    <description>Appsec and DevSecOps</description>
    <link>//</link>
    <atom:link href="//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 25 Sep 2018 09:52:41 -0500</pubDate>
    <lastBuildDate>Tue, 25 Sep 2018 09:52:41 -0500</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Protecting a shared Docker socket using a Golang reverse-proxy (1/4)</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;If you already worked a bit with Docker, maybe did you end-up in a situation were you needed to launch/create/manage a new container &lt;strong&gt;from&lt;/strong&gt; an already existing one. For example, when you are running a dockerized Jenkins instance and need to create ephemeral containers in your pipeline to perform build tasks.&lt;/p&gt;

&lt;p&gt;In such case, a quick Google search will offers you two main options :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Docker inside Docker (DinD) :&lt;/strong&gt; you perform a full Docker installation within you container. Basically, you run Docker on top of another Docker. I’m not a big fan of this approach and some people much more knowledgeable than me have explained &lt;a href=&quot;https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&quot;&gt;why it might be a bad idea&lt;/a&gt; (spoiler: filesystem issues and risks of corruption). This options however seems to remain relevant in some cases, for instance if you are using &lt;a href=&quot;https://applatix.com/case-docker-docker-kubernetes-part/&quot;&gt;Kubernetes&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Docker outside Docker (DooD) :&lt;/strong&gt; you share the Docker socket of the host with your hosted container.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -ti --rm -v /var/run/docker.sock:/var/run/docker.sock alpine&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Once inside the container, performing request to the docker socket become as simple as installing curl and doing :&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;curl --unix-socket /var/run/docker.sock http://localhost/containers/json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Obviously, you can also install the Docker cli for a user experience identical to the one you have on the host.&lt;/p&gt;

&lt;p&gt;In my case, I’m running my containers on a small dedicated server using Docker compose. Mainly to perform per commit build jobs on a couple of open-source projects I follow. So DinD doesn’t seems like a good option.&lt;/p&gt;

&lt;p&gt;This left us with the DooD approach. However, as a former “offensive security” guy, I can’t accept to break the isolation between my containers and my host so easily. Indeed, in case of compromising of the container with access to the Docker socket, getting root access on the host can be easily achieved.&lt;/p&gt;

&lt;p&gt;All  an attacker would have to do is to download the standalone &lt;a href=&quot;https://download.docker.com/linux/static/stable/x86_64/&quot;&gt;docker client&lt;/a&gt;, launch a new busybox container (running by default as root) mapping the root of the host to a directory, and then chroot into it :&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -u 0 -ti --rm -v /:/media/host/ busybox chroot /media/host&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note : This is the exact same reason why it is considered that being in the docker group is equal to have root privilege. It works from the host too.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;securing-the-docker-socket-using-nginx-&quot;&gt;Securing the Docker socket using Nginx ?&lt;/h2&gt;

&lt;p&gt;When I saw that the Docker socket gave access to a Web API, my first though was “reverse-proxy”. If you are not familiar with this concept, a reverse-proxy stand between a web server and its clients and forward their requests to it. A reverse-proxy also allow to perform different tasks such as caching, load-balancing and… requests filtering ! To solve our issue, we can map our docker socket to a reverse-proxy container, configure our docker client to work with a remote socket and filter its HTTP requests to only allow what we want.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/uploads/2018/09/schema-reverse-proxy.jpg&quot; alt=&quot;Static Library Link&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One of the most commonly used reverse proxy is Nginx, which happens to have a ready to use official image on &lt;a href=&quot;https://hub.docker.com/_/nginx/&quot;&gt;Dockerhub&lt;/a&gt;. Neat right ? No.&lt;/p&gt;

&lt;p&gt;By doing so, we basically move our risk of compromising from the Jenkins container to the Nginx one. The attack surface is reduced (since Jenkins is &lt;a href=&quot;https://www.cvedetails.com/product/34004/Jenkins-Jenkins.html?vendor_id=15865&quot;&gt;not realy&lt;/a&gt; the most secure software ever), but we still end-up with a full-sized docker container, either based on alpine or debian stretch, running a service with much more features than actually needed.&lt;/p&gt;

&lt;p&gt;In some (most ?) cases it may seems like an acceptable solution, but let’s get paranoid and see how we can do it better.&lt;/p&gt;

&lt;h2 id=&quot;scratch-images-and-golang-to-the-rescue&quot;&gt;Scratch images and Golang to the rescue&lt;/h2&gt;

&lt;p&gt;A neat way to have an as empty as possible docker image is to build it “FROM scratch”, which basicaly means that your image will &lt;a href=&quot;https://embano1.github.io/post/scratch/&quot;&gt;“only”&lt;/a&gt; contains what you put in it. No &lt;code class=&quot;highlighter-rouge&quot;&gt;sh&lt;/code&gt;, no &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin&lt;/code&gt;, no &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib&lt;/code&gt;, no &lt;code class=&quot;highlighter-rouge&quot;&gt;thing&lt;/code&gt;. The first question that should come up to your mind is : &lt;em&gt;What about dependencies ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you are coding in Java you need the JVM, if you are coding in Python you need the Python interpreter and if you are coding in C/C++ you have to wear your original &lt;em&gt;Jurassic Park&lt;/em&gt; t-shirt and code with &lt;em&gt;Stranger Things&lt;/em&gt; in the background for maximum efficiency. We don’t want that.&lt;/p&gt;

&lt;p&gt;Luckily, Golang is a language offering just the level of abstraction we need to code a reverse-proxy painlessly while offering all the capabilities of a compiled language, including &lt;strong&gt;static compilation&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/uploads/2018/09/StaticLibraryLink.png&quot; alt=&quot;Static Library Link&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Static compilation is a compilation process resulting in a standalone binary embeding all its dependencies. For instance, a software developed in C and statically compiled won’t rely on the system &lt;code class=&quot;highlighter-rouge&quot;&gt;libc&lt;/code&gt; but the one it as been compiled with. The same thing can be easily achieve in Go :&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CGO_ENABLED=0 GOOS=linux go build -a -ldflags '-extldflags &quot;-static&quot;' src/reverse-proxy.go&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;we-got-a-plan-&quot;&gt;We got a plan !&lt;/h2&gt;

&lt;p&gt;With this information in mind, all me now have to do is apply the classic “make it work, then make it better” method :&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Create a basic Go reverse-proxy and move it to a scratch image&lt;/li&gt;
  &lt;li&gt;Add filtering capabilities&lt;/li&gt;
  &lt;li&gt;Add HTTPS support, client authentication and per client filtering policies&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each of those points will be the subject of dedicated blog posts in this serie.&lt;/p&gt;

&lt;h2 id=&quot;alternative-solutions&quot;&gt;Alternative solutions&lt;/h2&gt;

&lt;p&gt;If you are looking for a production ready solution and are not realy interested into the DIY part, you may want to have a look at :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/open-policy-agent/opa&quot;&gt;Open Policy Agent&lt;/a&gt;, a general-purpose policy engine which happens to have a tutorial for &lt;a href=&quot;https://www.openpolicyagent.org/docs/docker-authorization.html&quot;&gt;this exact use case&lt;/a&gt;. However it requires to install a Docker plugin and doesn’t offer actual client authentication.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;Tyk&quot;&gt;https://github.com/TykTechnologies/tyk&lt;/a&gt;, a lightweight API Gateway coded in Go, offering filtering capabilities. However, it doesn’t seem to filter parameters.&lt;/li&gt;
  &lt;li&gt;Your current API gateway or reverse-proxy that may offer some kind of ACL capabilities for API requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&quot;&gt;https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://applatix.com/case-docker-docker-kubernetes-part/&quot;&gt;https://applatix.com/case-docker-docker-kubernetes-part/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://embano1.github.io/post/scratch/&quot;&gt;https://embano1.github.io/post/scratch/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bogotobogo.com/cplusplus/libraries.php&quot;&gt;https://www.bogotobogo.com/cplusplus/libraries.php&lt;/a&gt; [Static Library Link schema]&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/TykTechnologies/tyk&quot;&gt;https://github.com/TykTechnologies/tyk&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.openpolicyagent.org/docs/docker-authorization.html&quot;&gt;https://www.openpolicyagent.org/docs/docker-authorization.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 11:10:00 -0500</pubDate>
        <link>//golang-reverse-proxy-1-4/</link>
        <guid isPermaLink="true">//golang-reverse-proxy-1-4/</guid>
        
        <category>Docker</category>
        
        <category>Golang</category>
        
        
      </item>
    
  </channel>
</rss>
